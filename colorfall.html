
<style>

.css-treeview ul,
.css-treeview li
{
	padding: 0;
	margin: 0;
	list-style: none;
    
      padding: 0.5em;
}

.uiBlock{

    list-style-position:inside;
    border: 2px solid gray;
    margin:5px;

}

.css-treeview input
{
	position: absolute;
	opacity: 1;
}

.css-treeview
{
	font: normal 11px "Segoe UI", Arial, Sans-serif;
	-moz-user-select: none;
	-webkit-user-select: none;
	user-select: none;
    
      color: white;
      background: rgba(90, 90, 90, 0.5);
      padding: 0.5em;
      position: fixed;
      top: 10px;
      right: 10px;
      width: 300px;
      
    z-index: 10
    
}

.css-treeview a
{
	color: #00f;
	text-decoration: none;

}

.css-treeview a:hover
{
	text-decoration: underline;
}

.css-treeview input + label + ul
{
	margin: 0 0 0 22px;
}

.css-treeview input + label + ul
{
	display: none;
}

.css-treeview label,
.css-treeview label::before
{
	cursor: pointer;
}

.css-treeview input:disabled + label
{
	cursor: default;
	opacity: .6;
}

.css-treeview input:checked:not(:disabled) + label + ul
{
	display: block;
}

.css-treeview label,
.css-treeview label::before
{
	background: url("icons.png") no-repeat;
}

.css-treeview label,
.css-treeview a,
.css-treeview label::before
{
	display: inline-block;
	height: 16px;
	line-height: 16px;,
	vertical-align: middle;
}

.css-treeview label
{
	background-position: 18px 0;
}

.css-treeview label::before
{
	content: "";
	width: 16px;
	margin: 0 22px 0 0;
	vertical-align: middle;
	background-position: 0 -32px;
}

.css-treeview input:checked + label::before
{
	background-position: 0 -16px;
}

/* webkit adjacent element selector bugfix */
@media screen and (-webkit-min-device-pixel-ratio:0)
{
	.css-treeview 
	{
		-webkit-animation: webkit-adjacent-element-selector-bugfix infinite 1s;
	}
	
	@-webkit-keyframes webkit-adjacent-element-selector-bugfix 
	{
		from 
		{ 
			padding: 0;
		} 
		to 
		{ 
			padding: 0;
		}
	}
}

.twitter-follow-button {
  display: block;
  margin-left: auto;
  margin-right: auto;
  width: 50%;
}

.Control {
  background: rgba(128, 128, 128, 0.5);
  padding: 0.5em;
  position: fixed;
  top: 10px;
  right: 10px;
  width: 729px;
  visibility: hidden;
}
.filterSmall {
  background: rgba(128, 128, 128, 0.5);
  padding: 0.5em;
  position: fixed;
  top: 10px;
  left: 10px;
  width: 70px;
  visibility: hidden;
}
</style>

<div class="css-treeview">
    <div class="uiBlock" style="">

    <h2 style="text-align:center;"> TensorFlow Automata </h2>
    <p style="text-align:center;">by Nathan Epstein<a href="https://twitter.com/Aeium?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="false">Nathan @Aeium</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></p>
    </div>
	<ul>
		<li class="uiBlock"><input type="checkbox" id="item-0" /><label for="item-a">Info</label>
            <ul>
                <p>This page is a UI for exploring patterns generated by repeated discrete convolution combined with a technique called even-zeroing. Even zeroing is an operation similar to Modulo, but only "enforced" on zeros.</p> 
                <p>Ex: (10,11,12,13) mod 2 -> (0,1,0,1) vs (10,11,12,13) Even-Zero-mod 2 -> (0,11,0,13).</p>
                <p>The results are congruent mod 2 but the even zero technique preserves the full value of the numbers that are not 0 respective to the modulus. This allows for a greater variety and depth of color in the visualization. There are many possibilities, some seem chaotic and random and others seem bizarrely deliberate.<p>
                <p>Gallery Link coming soon</p>
                <p>Controls:</p>
                <p>Advance the automaton using the button in basic controls, or use the W key. The convolutional filters can be edited in Automton Parameters -> Conv Filter Editor. Even-zero-mods can be edited in Automaton Parameters -> mods</p>
            </ul>
        </li>
		<li class="uiBlock"><input type="checkbox" id="item-0" /><label for="item-b">Basic Controls</label>
			<ul>

						<li><button onclick="advanceAuto()">Advance Automaton (W key)</button></li>
						<li><button onclick="resetAuto()">Reset Automaton (R key)</button></li>
			</ul>
		</li>
		<li class="uiBlock"><input type="checkbox" id="item-0" /><label for="item-0">Display Settings</label>
			<ul>

						<li><button onclick="reSize()">Resize Canvas</button></li>
						<li> <p>Automata Iteration Display Stride:<input type="text" id="Stride" value="1" style="position:relative; background: rgba(230,230,230,.5); z-index: 5; border:2px white; visibility: visible; 
  color: white; color:black;" onkeyup="setDispStride(this.value)" ></p></li>
						<li><input onclick="togAnimate()" type="checkbox" id="item-0-1" /><label for="item-0-1">Toggle Animate</label></li>
						<li><input onclick="toggleCounter()" type="checkbox" id="item-0-2" /><label for="item-0-2">Toggle Iteration Counter</label></li>
			</ul>
		</li>
		<li class="uiBlock"><input type="checkbox" id="item-1" /><label for="item-1">Automaton Parameters</label>
			<ul>

						<li><li><input onclick="patternView()" type="checkbox" id="item-1-1" /><label for="item-1-1">Conv Filter Editor</label></li></li>
						<li> <p>Mods: (comma seperate for multiple mods)<input type="text" id="Stride" value="2" style="position:relative; background: rgba(230,230,230,.5); z-index: 5; border:2px white; visibility: visible; 
  color: white; color:black;" onkeyup="setMods(this.value)"></p></li>
			</ul>
		</li>
		<li class="uiBlock"><input type="checkbox" id="item-0" /><label for="item-b">Pixel Edit</label>
			<ul>
						<li> <p>Pixel Edit Value<input type="text" id="Stride" value="1" style="position:relative; background: rgba(230,230,230,.5); z-index: 5; border:2px white; visibility: visible; 
  color: white; color:black;" onkeyup="setPixEdit(this.value)" ></p></li>
						<li><input onclick="togPixEdit()" type="checkbox" id="item-0-1" /><label for="item-3-1">Toggle Pixel Edit Mode</label></li>
			</ul>
	</ul>
</div>


<div id="container">
<canvas id="myCanvas" style="position:fixed; left:0; top:0; width:100%; height:100%; zindex:1;">
Your browser does not support the HTML5 canvas tag.</canvas>

<canvas id="myCanvas2" width="729" height="729" style="position:fixed; border:1px solid #d3d3d3; zindex:5; display: none">
Your browser does not support the HTML5 canvas tag.</canvas>


</div>

<script>

/* old html
<div class="Control">

 <button onclick="reSize()">Resize Canvas</button>
 <button onclick="patternView()">Filter Editor</button>
 <button onclick="setMods()">Set Mods</button>
 <button onclick="advanceAuto()">Advance Automation (W key also works)</button>
 <button onclick="toggleCounter()">Toggle Counter</button>
 <button onclick="togAnimate()">Toggle Animate</button>
 
 <p> Page built by Nathan Epstein (Aeium) </p>


<div class="filterSmall">

    <p> Filter Edit </p>

    <button onclick="expandFilter()">Expand</button>

</div>
*/


// https://css-tricks.com/snippets/css/nested-expandable-folders/ source for treeview UI

//<script src="https://cdn.jsdelivr.net/gh/nicolaspanel/numjs@0.15.1/dist/numjs.min.js">

/*<script type='text/javascript' src='E:\numjs_local\dist\numjs.js'>

<script src="math.min.js" type="text/javascript">*/

function getParameterByName(name, url) {
    if (!url) url = window.location.href;
    name = name.replace(/[\[\]]/g, "\\$&");
    var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
        results = regex.exec(url);
    if (!results) return null;
    if (!results[2]) return '';
    return decodeURIComponent(results[2].replace(/\+/g, " "));
}

var canvas = document.getElementById("myCanvas");
var ctx    = canvas.getContext("2d");

var canvas2 = document.getElementById("myCanvas2");
var ctx2    = canvas2.getContext("2d");

var heightCanvas = parseInt(getParameterByName('cH'))
var widthCanvas  = parseInt(getParameterByName('cW'))
var heightPixels = parseInt(getParameterByName('pH'))
var widthPixels  = parseInt(getParameterByName('pW'))

var reload = false

var defaultHeight = window.innerHeight
var defaultWidth  = window.innerWidth
var defaultHeightCells = Math.floor(window.innerHeight/4)
var defaultWidthCells = Math.floor(defaultHeightCells * (defaultWidth/defaultHeight))



if(mod(defaultWidthCells,2) == 0){
    defaultWidthCells -= 1
}
if(mod(defaultHeightCells,2) == 0){
    defaultHeightCells -= 1
} 

var frame2Size = 729

//console.log(window.innerHeight)
//console.log(Math.floor(window.innerHeight/4))

var displayCounter = true

// load defaults if arguments are not provided
if(isNaN(heightCanvas)){heightCanvas = defaultHeight; reload = true;}
else if(heightCanvas != window.innerHeight){
    ctx.canvas.height = heightCanvas

}
if(isNaN(widthCanvas)){widthCanvas  = defaultWidth; reload = true;}
else if(widthCanvas != window.innerWidth){
    ctx.canvas.width = widthCanvas

}
if(isNaN(heightPixels)){heightPixels =  defaultHeightCells; reload = true;}
if(isNaN(widthPixels)){widthPixels  =  defaultWidthCells; reload = true;}

ctx.canvas.height = heightCanvas
ctx.canvas.width  = widthCanvas

//ctx = canvas.getContext('2d')  // lets try this again

var cellX = widthCanvas  / widthPixels
var cellY = heightCanvas / heightPixels
    
//console.log("~~~~~")
    
//console.log(getParameterByName('hC'))

if(reload){

    window.location.search += '&cH='+heightCanvas.toString()+'&cW='+widthCanvas.toString()+'&pH='+heightPixels.toString()+'&pW='+widthPixels.toString()

}

function reSize() {
    var txt;
    var vars = prompt("Edit numbers to reload canvas with new dimensions: \n <Canvas Height, Canvas Width, Active Cells Y, Active Cells X>", heightCanvas.toString() + ", " + widthCanvas.toString()+ ", " + heightPixels.toString()+ ", " + widthPixels.toString());
    varList = vars.split(',')
    var pass = false
    
    ////console.logg(varList.length)
    
    ////console.logg(!isNaN(varList[0]) && !isNaN(varList[1]) && !isNaN(varList[2]) && !isNaN(varList[3]))

    if(varList.length == 4){
    
        ////console.logg(varList)
    
        if(!isNaN(varList[0]) && !isNaN(varList[1]) && !isNaN(varList[2]) && !isNaN(varList[3])){     
            ////console.logg("pass number check")     
            pass = true
        }
    }
    
    if (!pass) {
        txt = "Invalid input, no changes made";
    } else {
        
        heightCanvas = parseInt(varList[0])
        widthCanvas  = parseInt(varList[1])
        heightPixels = parseInt(varList[2])
        widthPixels  = parseInt(varList[3])
         
        window.location.search = '&cH='+heightCanvas.toString()+'&cW='+widthCanvas.toString()+'&pH='+heightPixels.toString()+'&pW='+widthPixels.toString()
        
    }
    //document.getElementById("demo").innerHTML = txt;
}

var patternViewDisplay = false

function patternView(){
    if(patternViewDisplay == false){
        document.getElementById('myCanvas2').style.display = "block"
        patternViewDisplay = true
    } else {
        document.getElementById('myCanvas2').style.display = "none"
        patternViewDisplay = false
    }

    ////console.logg(document.getElementById('myCanvas2').style.display)

    ////console.logg(patternViewDisplay)
    
}

var modList  = [3,14]
var globalMod = 131072

function setMods(modsStr){

    var modsStrArray = modsStr.split(',')
    
    ////console.logg(modsStrArray)
    
    modList = []
    
    for (var i = 0; i < modsStrArray.length; i++){
    
        ////console.logg(modsStrArray[i])
        ////console.logg(isNaN(modsStrArray[i]))
        
    
        if(! isNaN(modsStrArray[i])){
            modList.push(parseInt(modsStrArray[i]))
        }
    
    }
    
    //////console.logg(modList)
    
    globalMod = modList[0]
    var count = 1
        
    ////console.logg(globalMod)
    while(globalMod < 65536*2){
        
        //////console.logg(globalMod)
        globalMod = globalMod * modList[mod(count,modList.length)]
        count++
        //////console.logg(globalMod)
    }
    
    //////console.logg(globalMod)


}


var cellSize = 1

var templateSize = 5

var displayStride = 1

function setDispStride(newVal){

    displayStride = parseInt(newVal)
}

var pixEditVal = 1

function setPixEdit(newVal){

    pixEditVal = newVal

}

var calcBatch = 0     // keep track of what frame until next delay

var displayStartFrame  = 1

var frameNum = 0

function mod(n, m) {
        return ((n % m) + m) % m;
}


function modularPaddArray(prePadArray, border){  // buffer should be input tile radius

    var ppa = prePadArray
    var b   = (border.shape[0]-1) /2   // size of padding
       
    var upper_pad = ppa.slice([ppa.shape[0]-b,0],[b,ppa.shape[1]])
    var lower_pad = ppa.slice([0,0],[b,ppa.shape[1]])
    
    var partial   = tf.concat([upper_pad, ppa, lower_pad], axis = 0)
    
    var left_pad  = partial.slice([0,partial.shape[1] - b],[partial.shape[0],b])
     
    var right_pad = partial.slice([0,0],[partial.shape[0],b])
  
    return tf.concat([left_pad, partial, right_pad], axis = 1) ////////console.logg(padded)

}

function modularPaddArray1d(prePadArray){  // buffer should be input tile radius

    var ppa = prePadArray
    
    var left_pad  = ppa.slice([0,ppa.shape[0]-1],[1,1])  // this is the pad that gets placed onto the left side from the right, not from the left
     
    var right_pad = ppa.slice([0,0],[1,1])
    
    ////console.logg('pads:')
    ////console.logg(right_pad.shape)
    ////console.logg(left_pad.shape)
    ////console.logg('----')
  
    return tf.concat([left_pad, ppa, right_pad], axis = 1) ////////console.logg(padded)

}


// iteration 135
// -2 from middle

function setPix1(x, y, value){


    if(value != 0){value += BigInt(200)}
    
    /*
    if(x == Math.floor(values.length/2)){
        value = 60
    }
    if(x == Math.floor(values.length/2) -60){

        if(y == 200 || y == 201 ||y == 202 ||y == 203){
        
            //console.log('setpix val')
            //console.log(value)
        }else{
            value = 60
        }
    }
    if(mod(y, 10) == 0){
        value = 100
    }*/
    
    //var bValue = BigInt(value)

    // this mod needs to be 255
    //var color1 = mod((value << 0) , 255)
    //var color2 = mod((value << 5) , 255)
    //var color3 = mod((value << 2) , 255)

    var color1 = Number(mod((value << BigInt(0)) , BigInt(255)))
    var color2 = Number(mod((value << BigInt(5)) , BigInt(255)))
    var color3 = Number(mod((value << BigInt(2)) , BigInt(255)))
    
    setPix(x,y, color1, color2, color3)

}

function setPix(x, y, r, g, b){


    var xPix = x * cellX;
    var yPix = y * cellY;
    
    ////console.log(y)
    ////console.log(yPix)

    ctx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
    
    ctx.fillRect(xPix, yPix , cellX, cellY);

}

var rulebook = [0,1,1,1,1,0,0,0]

var valuesB = []

var display = []

function applyRule1(){

    ////console.log(values.slice(225,250))
    
    values = display[displayRow]
    
    valuesB.fill(BigInt(0))
    
    var min = BigInt(0)
    var max = BigInt(0)

    for(var i = 0; i < values.length; i++){
    
        value = BigInt(0)
        state = 0
        
        left   = null
        center = null
        right  = null
        
        if(i == 0){
            left = values[values.length-1]
        }
        else{
            left = values[i-1]
        }
        if(i == values.length-1){
            right = values[0]
        }
        else{
            right = values[i+1]
        }
        
        center = values[i]
        
            
        value = left + center + right
        
        if(left != 0){
            state += 4
        }
        if(center != 0){
            state += 2
        }
        if(right != 0){
            state += 1
        }
        
        //print(state)
        
        /*    
        if(rulebook[state] != 1){
            
            value = 0
            
            // making it explicit did something weird
            //if(value > 2147483647): # seems like the pattern I want needs overflow so making it explicit
            //    value = -2147483648 + (value -  2147483647)
            
        } else {
            if(value > 9223372036854775807){
            
                ////console.log(value)
            
                value -= (9223372036854775808 + 9223372036854775807)
                
                //console.log(value)
                //console.log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
            
            }
            else if(value < -9223372036854775808){
            
                value += (9223372036854775808 + 9223372036854775807)
            
            }
            
            if(mod(value,3) == 0){
                value = 0
            }
            if(mod(value,14) == 0){
                value = 0
            }
        }*/
        /*
        if(value > 9223372036854775807){
            
            ////console.log(value)
        
            value -= BigInt(9223372036854775808 + 9223372036854775807)
            
            //console.log(value)
            //console.log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
        
        }
        else if(value < -9223372036854775808){
        
            value += (9223372036854775808 + 9223372036854775807)
        
        }*/
        
        if(rulebook[state] == 1){
        
            valuesB[i] = value
        
        }
        
        
        if(value < min){
        
            min = value
        
        }
        if(value > max){
        
            max = value
        
        }

            
        
        //#a = np.mod(b,2147483648) # max int 32, so two of these can't overflow 64
        
        //#print (row)
        
        //result.append(np.copy(a))
    
    }
    
    for(var i = 0; i < valuesB.length; i++){
    
        if(mod(valuesB[i],BigInt(3)) == 0){
            valuesB[i] = BigInt(0)
        }        
        if(mod(valuesB[i],BigInt(14)) == 0){
            valuesB[i] = BigInt(0)
        }       
    }
    
    ////console.log(min)
    ////console.log(max)
    
    ////console.log(valuesB[Math.floor(valuesB.length/2)])
    
    ////console.log(valuesB)
    ////console.log(values)
    
    if(displayRow == display.length){
        display.push(valuesB.slice())
    }else{
        display[displayRow+1] = valuesB.slice()
    }
    //values = valuesB.slice()
    
// iteration 135
// -2 from middle
    
    if(frameNum == 134 || frameNum == 135 || frameNum == 136 || frameNum == 137){
    
        //console.log(values.slice(225,250))
    
        //console.log(values[Math.floor(values.length/2) -2])
        ////console.log(values[Math.floor(values.length/2) -60])
    }
    
    
    if(frameNum == 200 || frameNum == 201 || frameNum == 202 || frameNum == 203){
    
        ////console.log(values.slice(225,250))
    
        ////console.log(values[Math.floor(values.length/2) -2])
        //console.log(values[Math.floor(values.length/2) -60])
    }
    
} // colorfall



function displayAuto(){

    
    if(displayRow > heightPixels){
    
        ////console.log("yes, " + display.length + " is bigger than " + heightPixels)
    
        display = display.slice(display.length-heightPixels, display.length)
        displayRow -= 1
    
    }
    
    ////console.log(display.length)

    for(var i = 0; i < display.length; i++){
        for(var j = 0; j < values.length; j++){
        
            setPix1(j,i,display[i][j])
        
        }
    }
    
    displayRow += 1
    
}


//var frame1 = nj.zeros([frameSize,frameSize])
//var frame2 = nj.zeros((frameSize,frameSize), dtype = uint32)

// https://stackoverflow.com/questions/34685947/adjust-single-value-within-tensor-tensorflow/34686952#34686952

var valuesA = new BigInt64Array(1 * widthPixels).fill(BigInt(0))
var valuesB = new BigInt64Array(valuesA.length).fill(BigInt(0))

var startValue = BigInt(1)  // maybe allow this to be changed later
valuesA[Math.floor(1*widthPixels/2)] = startValue

var displayRow = 0

display.push(valuesA)


function pixEdit(xCo, yCo){

    //////console.logg(values.length)
    
    //////console.logg("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
    //////console.logg(heightPixels)
    //////console.logg(widthPixels)
    //////console.logg(widthPixels*heightPixels)

    displayRow = yCo
    display[yCo][xCo] -= 1
    values = display[yCo].slice()
    
}

pixEditMode = false

function togPixEdit(){

    pixEditMode = !pixEditMode

}

//frame1.print()

//var template = nj.array([[0,1,1,1,1,0],[1,0,0,0,0,1],[1,0,1,0,0,1],[0,1,1,1,1,0],[0,0,0,0,0,0],[0,1,1,1,1,1],[1,0,0,1,0,0,],[0,1,1,1,1,1,],[0,0,0,0,0,0],[0,0,1,1,1,0],[0,1,0,1,0,1],[0,0,1,0,0,1],
 //                       [0,0,0,0,0,0],[1,0,1,1,1,1],[0,0,0,0,0,0],[0,0,1,1,1,0],[0,0,0,0,0,1],[0,0,0,0,0,1],[0,0,1,1,1,0],[0,0,0,0,0,0],[0,0,0,1,1,1],[0,0,1,0,0,0],[0,0,0,1,1,1],[0,0,1,0,0,0],[0,0,0,1,1,1]])

//var templateTop = nj.zeros([25,9])
//var templateBot = nj.zeros([25,10])

//var template = nj.ones([9,9])

////////console.logg(template.shape)
////////console.logg(templateTop.shape)

//template = nj.concatenate(nj.concatenate(templateTop, template), templateBot)

                        
//////console.logg(template.shape)

var filterValues = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
 
/* 
const template3  = tf.variable(tf.zeros([ 3, 3,1,1]))
const template5  = tf.variable(tf.zeros([ 5, 5,1,1]))
const template7  = tf.variable(tf.zeros([ 7, 7,1,1]))
const template9  = tf.variable(tf.zeros([ 9, 9,1,1]))
const template11 = tf.variable(tf.zeros([11,11,1,1]))
*/


var whichTempate = 1  // 0 -> 3, 1 -> 5, 2 -> 7, 3 -> 9, 4 -> 11  thats about as close to making sense as this will get I think


ctx.fillStyle = 'rgb(0,0,0)';

ctx.fillRect(0,0, heightPixels, widthPixels);


//////console.logg(template.shape)

//array = nj.array([1,2,3,4,5,6,7,8,9])

//////console.logg("what")

//////console.logg(array)

//////console.logg("testing math.js")

function resetGrid(){

ctx2.fillStyle = 'rgb(255,255,255)';
ctx2.fillRect(0, 0, frame2Size, frame2Size)

ctx2.fillStyle = 'rgb(0,0,0)';

// template grid select buttons
for(var i = 0; i < 8; i++){
    ctx2.fillRect(40+80*i, 40, 40, 40)
}

ctx2.fillRect(40, frame2Size - 80, 80, 40)


}

function invertConvPattern(){

    templateList[whichTempate].assign(templateList[whichTempate].add(tf.scalar(1)).mod(tf.scalar(2)))
    displayTemplateGrid()

}



function setPatternGridSize(size){

    // 0 -> 3, 1 -> 5, 2 -> 7, 3 -> 9, 4 -> 11  

    var targetTemplate = Math.floor(size / 2) - 1

    var gridSize = (whichTempate+1) * 2 + 1

    //////console.logg(targetTemplate)
    //////console.logg(whichTempate)
    
   // ////console.logg(templateList[targetTemplate].shape)
    //////console.logg(templateList[targetTemplate].print())
    
    ////console.logg(size)
    
    ////console.logg(gridSize)
    
    if(size > gridSize){
    
        ////console.logg("size > gridsize")
        
        var diff = (size - gridSize)/2
        
        ////console.logg(diff)
        
        ////console.logg(templateList[whichTempate].shape)
        
        templateList[whichTempate].pad([[diff,diff],[diff,diff],[0,0],[0,0]]).print()
        
        ////console.logg("test")
        
        //////console.logg(templateList[whichTempate].pad([diff,diff],[diff,diff]).shape)
    
        //templateList[targetTemplate].assign(templateList[whichTempate].pad([diff,diff],[diff,diff]))
    
    }
    
    if(size < gridSize){
    
        var diff = (gridSize - size)/2
    
        //////console.logg(diff)
        //////console.logg(gridSize)
    
        //templateList[whichTempate].print()
        
        //templateList[whichTempate].slice([diff, diff],[gridSize-diff*2,gridSize-diff*2]).print()
    
        templateList[targetTemplate].assign(templateList[whichTempate].slice([diff, diff],[gridSize-diff*2,gridSize-diff*2]))
    
    }
    
    whichTempate = targetTemplate
    
    //////console.logg(whichTempate)
    
    //templateList[whichTempate].print()
    
    displayTemplateGrid()

}


function toggleCounter(){

    displayCounter = ! displayCounter
    
    tf.toPixels(displayVar2, canvas).then(function(){
    
        if(displayCounter){
            ctx.font = Math.floor(widthCanvas/15).toString() + "px Arial"
            ctx.fillStyle = "white"
            ctx.fillText(frameNum.toString() , canvas.width- canvas.width*(19/20), canvas.height -      canvas.height*(1/20))}
    })

}

function clearFrame(){

    tf.tidy(() => {
    frame1.assign(tf.tensor(values, [displayPixelSize,displayPixelSize,1]))
    frameNum = 0
    display(frame1)
    })

}

var animate = false

function togAnimate(){

    animate = ! animate

}

function advanceAuto(){

            document.getElementById('myCanvas').style.height = heightCanvas
            document.getElementById('myCanvas').style.width  = widthCanvas

            ////console.logg("DISPLAYSTRIDE = " + displayStride.toString())

            ////console.logg(frameNum)
            if(displayStride != 1){
                while(true){
            
                    ////console.logg("DISPLAYSTRIDE = " + displayStride.toString())
            
                    ////console.logg(mod(frameNum,2))
                    ////console.logg(mod(frameNum+1,2))
            
                    ////console.logg(displayStride)
            
                    ////console.logg(mod(frameNum,displayStride)) 
                    ////console.logg(mod((frameNum + 1),displayStride)) 
                    
                    ////console.logg("displayStart = " + displayStartFrame.toString())
    
                    if(mod((frameNum + 1),displayStride)   == displayStartFrame){
    
                        ////console.logg(frame1.shape)
                        applyRule1()
                        ////console.logg(frame1.shape)
                        //////console.logg("test1")
                        frameNum++
                        ////console.logg(frameNum)
                        ////console.logg("disp loop")
                        displayAuto()
                        
                        if(displayCounter){
                            ctx.font = Math.floor(widthCanvas/15).toString() + "px Arial"
                            ctx.fillStyle = "white"
                            ctx.fillText(frameNum.toString() , canvas.width- canvas.width*(19/20), canvas.height -      canvas.height*(1/20))
                        }
                        
                        if(animate){
                            window.requestAnimationFrame(advanceAuto);
                        }
                    

                        break
                    }
                    else{
           
            
                        ////console.logg(frame1.shape)
                        applyRule1()
                        ////console.logg(frame1.shape)
                        //////console.logg("test1")
                        frameNum++
        
                        //frame1.print()
                        //template.print()
        

                    }
                }
            }
                
            else{
                

                    ////console.logg(frame1.shape)
                    applyRule1()
                    ////console.logg(frame1.shape)
                    //////console.logg("test1")
                    frameNum++
        
                    //frame1.print()
                    //template.print()
                    ////console.logg(frameNum)
                    ////console.logg("disp loop")
                    displayAuto()
                        
                    
                    
                    if(displayCounter){
                        ctx.font = Math.floor(widthCanvas/15).toString() + "px Arial"
                        ctx.fillStyle = "white"
                        ctx.fillText(frameNum.toString() , canvas.width- canvas.width*(19/20), canvas.height -      canvas.height*(1/20))
                    }
                    
                    if(animate){
                        window.requestAnimationFrame(advanceAuto);
                    }
                    
               
                    

            }
            
        ////console.logg("number of tensors:")
        ////console.logg(tf.memory().numTensors)
        ////console.logg("~~~~~~~~~~~~~~~~~")
            
}

document.onkeydown = function(e) {
    switch (e.keyCode) {
        case 8:
        
            clearFrame()
            break
    
        case 87:
        
            ////console.logg("w key pressed")
            advanceAuto()

            break
    }
}
        
document.getElementById("container").addEventListener('click', function(event) {

    //frame1.print()
    //template.print()
    

    //tf.toPixels(frame1, canvas)
    
    
    var canvas1Left = canvas.offsetLeft;
    var canvas1Top  = canvas.offsetTop;
    
    var pixX1 = event.pageX - canvas1Left;
    var pixY1 = event.pageY - canvas1Top;
    
    var canvas2Left = canvas2.offsetLeft;
    var canvas2Top  = canvas2.offsetTop;
    
    var pixX2 = event.pageX - canvas2Left;
    var pixY2 = event.pageY - canvas2Top;
    
    
    //if(pixY1 >= 0 && pixY1 <= frameSize){

        // these functions both assign the new value to frame1 so they don't need to return anything

    //}
    //else{
    if(document.getElementById('myCanvas2').style.display != 'none'){  // edit conv pattern via clicks

    
        if(pixY2 >= 40 && pixY2 <= 80){
    
            if(mod(pixX2,80) >= 40){
        
                var gridSize = 1+ 2 * (Math.floor(pixX2 / 80) + 1)
        
                setPatternGridSize(gridSize)


            }
        }
        
        if(pixY2 >= 120){
        
            flipTemplateBit(pixY2, pixX2)
        
        }
        
        if(pixY2 > frame2Size - 80 && pixY2 < frame2Size - 40 && pixX2 > 40 && pixX2 < 120){
        
            invertConvPattern()
        
        }
    } else if (pixEditMode){  // edit pixels in main canvas // for now easier to not allow both types of click edits at the same time
    
            //var heightCanvas = parseInt(getParameterByName('cH'))
            //var widthCanvas  = parseInt(getParameterByName('cW'))
            //var heightPixels = parseInt(getParameterByName('pH'))
            //var widthPixels  = parseInt(getParameterByName('pW'))
    
            var editX = Math.floor(pixX1 / (widthCanvas / widthPixels))
            var editY = Math.floor(pixY1 / (heightCanvas / heightPixels))
    
            pixEdit(editX, editY)
    
    }
    
}); 




</script>